package codigo;
import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import codigo.Traductor.Instruccion;
import codigo.Traductor.TipoInstruccion;

parser code {:
    private java.util.List<String> syntaxErrors = new java.util.ArrayList<>();
    private Symbol lastToken = null;
    private List<String> erroresSemanticos = new ArrayList<>();
    private SemanticAnalyzer semanticAnalyzer;
    private TablaSimbolos tablaSimbolos;
    private String ambitoActual = "Global";
    private ArrayList<Instruccion> instrucciones = new ArrayList<>();
    private String currentFunction = null;

    // Inicialización
{
        tablaSimbolos = new TablaSimbolos();
        semanticAnalyzer = new SemanticAnalyzer(tablaSimbolos);
        erroresSemanticos = new ArrayList<>();
        syntaxErrors = new ArrayList<>();
        instrucciones = new ArrayList<>();
        ambitoActual = "Global";
        System.out.println("Parser inicializado correctamente");

    }

    private void addInstruccion(Instruccion instruccion) {
        if (instruccion != null) {
            System.out.println("Agregando instrucción: " + instruccion.getTipo() + " - " + instruccion.getOperandoIzq());
            instrucciones.add(instruccion);
        }
    }

    private void enterScope(String newScope) {
        String oldScope = ambitoActual;
        ambitoActual = newScope;
        System.out.println("Entrando a ámbito: " + ambitoActual + " desde: " + oldScope);
    }

    private void exitScope() {
        String oldScope = ambitoActual;
        ambitoActual = ambitoActual.contains("_") ? 
                       ambitoActual.substring(0, ambitoActual.lastIndexOf('_')) : 
                       "Global";
        System.out.println("Saliendo de ámbito: " + oldScope + " a: " + ambitoActual);
    }

    private void handleDeclaration(Variable var) {
        if (var != null) {
            System.out.println("Manejando declaración de: " + var.getIdentificador() + 
                             " en ámbito: " + ambitoActual);
            
            // Verificar si la variable ya existe en el ámbito actual
            if (tablaSimbolos.existeSimboloEnAmbito(var.getIdentificador(), ambitoActual)) {
                semanticAnalyzer.addError("Variable '" + var.getIdentificador() + 
                                        "' ya declarada en el ámbito " + ambitoActual, 
                                        var.getFila());
                return;
            }
            
            var.setAmbito(ambitoActual);
            tablaSimbolos.insertar(var);
            addInstruccion(new Instruccion(TipoInstruccion.DECLARACION, 
                                         var.getIdentificador(), 
                                         null, null, null, 
                                         var.getFila()));
        }
    }

    public List<String> getSyntaxErrors() {
        return syntaxErrors;
    }
    
    public List<String> getSemanticErrors() {
        return semanticAnalyzer != null ? semanticAnalyzer.getErrores() : new ArrayList<>();
    }
    
    public TablaSimbolos getTablaSimbolos() {
        return tablaSimbolos;
    }
    
    public ArrayList<Instruccion> getInstrucciones() {
        return instrucciones;
    }

    private void addError(int line, String message) {
        String error = String.format("Línea %d: Error sintáctico - %s", line, message);
        if (!syntaxErrors.contains(error)) {
            syntaxErrors.add(error);
        }
    }

    public void syntax_error(Symbol s) {
        if (s == null) return;
        int line = s.left;
        if (line <= 0) return; 
        lastToken = s;
    }

    public void unrecovered_syntax_error(Symbol s) {
        if (s != null && s.left > 0) {
            addError(s.left, "Error irrecuperable en la estructura");
        }
    }

private void handleFunctionDeclaration(String id, TipoDato tipo, List<Variable> params, int line) {
    if (tablaSimbolos.existeFuncion(id)) {
        semanticAnalyzer.addError("Función '" + id + "' ya declarada", line);
        return;
    }
    
    Funcion func = new Funcion(id, "Global", params, tipo, line, 0);
    tablaSimbolos.insertar(func);
    currentFunction = id;
    enterScope(id);
    
    // Registrar parámetros en el ámbito de la función
    if (params != null) {
        for (Variable param : params) {
            param.setAmbito(id);
            handleDeclaration(param);
        }
    }
}
:};

/* Terminals */
terminal            PLUS_PLUS, MINUS_MINUS, PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal            ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIVIDE_ASSIGN;
terminal            EQUALS, GTEQ, GT, LTEQ, LT, NOT_EQUALS, OR, AND, NOT;
terminal            LPAREN, RPAREN, SEMICOLON, LBRACE, RBRACE, COMMA, COLON;
terminal            INT, VOID, CHAR, LONG, SHORT, MAIN;  // Añadido MAIN
terminal String     IDENTIFIER;
terminal Integer    NUMBER;
terminal            IF, ELSE, WHILE, DO, FOR;
terminal            BREAK, CONTINUE, RETURN;
terminal            SWITCH, CASE, DEFAULT;
terminal            READ, WRITE, CONST;
terminal            UMINUS;

/* Non-terminals */
non terminal            program;
non terminal            global_declarations;
non terminal            global_declaration;
non terminal            variable_declaration;
non terminal            statement_list;
non terminal            statement;
non terminal            compound_statement;
non terminal            expression_statement;
non terminal            selection_statement;
non terminal            iteration_statement;
non terminal            jump_statement;
non terminal Expression expression;
non terminal Expression assignment_expression;
non terminal Expression arithmetic_expression;
non terminal Expression multiplicative_expression;
non terminal Expression primary_expression;
non terminal List<Variable> identifier_list;
non terminal            main_function;
non terminal Instruccion condition;
non terminal Instruccion logical_expression;
non terminal Instruccion relational_expression;
non terminal String     comparison_operator;
non terminal TipoDato   type;


/* Precedences */
precedence left     OR;
precedence left     AND;
precedence left     EQUALS, NOT_EQUALS;
precedence left     LT, GT, LTEQ, GTEQ;
precedence left     PLUS, MINUS;
precedence left     TIMES, DIVIDE, MOD;
precedence right    NOT, UMINUS;
precedence left     PLUS_PLUS, MINUS_MINUS;

/* Grammar */
start with program;

program ::= 
    global_declarations main_function
    | main_function
    ;

global_declarations ::=
    global_declarations global_declaration
    | global_declaration
    ;

global_declaration ::=
    variable_declaration
    ;

variable_declaration ::= 
    type:t identifier_list:vl SEMICOLON
    {:
        if (vl != null) {
            for (Variable var : vl) {
                var.setTipo(t);
                var.setAmbito(ambitoActual);
                handleDeclaration(var);
            }
        }
    :}
    ;

identifier_list ::= 
    identifier_list:vl COMMA IDENTIFIER:id
    {:
        List<Variable> list = vl;
        if (list == null) list = new ArrayList<>();
        list.add(new Variable(id.toString(), null, ambitoActual, idleft, idright));
        RESULT = list;
    :}
    | IDENTIFIER:id
    {:
        List<Variable> list = new ArrayList<>();
        list.add(new Variable(id.toString(), null, ambitoActual, idleft, idright));
        RESULT = list;
    :}
    ;

main_function ::=
    INT MAIN LPAREN RPAREN
    {:
        handleFunctionDeclaration("main", TipoDato.INT, new ArrayList<>(), mainleft);
    :}
    compound_statement
    {:
        exitScope();
        currentFunction = null;
    :}
    ;

compound_statement ::= 
    LBRACE
    {:
        String newScope = ambitoActual + "_" + lbraceleft;
        enterScope(newScope);
    :}
    statement_list
    RBRACE
    {:
        exitScope();
    :}
    ;

statement_list ::= 
    statement_list statement
    | /* empty */
    ;

statement ::=
    variable_declaration
    | expression_statement
    | compound_statement
    | selection_statement
    | iteration_statement
    | jump_statement
    ;

expression_statement ::=
    expression:e SEMICOLON
    {:
        if (e != null) {
            addInstruccion(new Instruccion(TipoInstruccion.EXPRESION, e.toString(), null, null, null, eleft));
        }
    :}
    | SEMICOLON
    ;

expression ::=
    assignment_expression:e
    {: RESULT = e; :}
    ;

assignment_expression ::=
    IDENTIFIER:id ASSIGN arithmetic_expression:e
    {:
        semanticAnalyzer.checkUndefinedVariable(id, ambitoActual, idleft);
        if (!semanticAnalyzer.hasError()) {
            addInstruccion(new Instruccion(TipoInstruccion.ASIGNACION, id, null, e.toString(), null, idleft));
            RESULT = e;
        }
    :}
    | arithmetic_expression:e
    {: RESULT = e; :}
    ;

arithmetic_expression ::=
    arithmetic_expression:a PLUS multiplicative_expression:m
    {:
        addInstruccion(new Instruccion(TipoInstruccion.OPERACION_ARITMETICA, a.toString(), "+", m.toString(), null, aleft));
        RESULT = semanticAnalyzer.foldConstants(a, "+", m);
    :}
    | arithmetic_expression:a MINUS multiplicative_expression:m
    {:
        addInstruccion(new Instruccion(TipoInstruccion.OPERACION_ARITMETICA, a.toString(), "-", m.toString(), null, aleft));
        RESULT = semanticAnalyzer.foldConstants(a, "-", m);
    :}
    | multiplicative_expression:m
    {: RESULT = m; :}
    ;

multiplicative_expression ::=
    multiplicative_expression:m TIMES primary_expression:p
    {:
        addInstruccion(new Instruccion(TipoInstruccion.OPERACION_ARITMETICA, m.toString(), "*", p.toString(), null, mleft));
        RESULT = semanticAnalyzer.foldConstants(m, "*", p);
    :}
    | multiplicative_expression:m DIVIDE primary_expression:p
    {:
        addInstruccion(new Instruccion(TipoInstruccion.OPERACION_ARITMETICA, m.toString(), "/", p.toString(), null, mleft));
        RESULT = semanticAnalyzer.foldConstants(m, "/", p);
    :}
    | primary_expression:p
    {: RESULT = p; :}
    ;

primary_expression ::=
    IDENTIFIER:id
    {:
        semanticAnalyzer.checkUndefinedVariable(id, ambitoActual, idleft);
        Expression constValue = semanticAnalyzer.propagateConstants(id, ambitoActual);
        RESULT = constValue != null ? constValue : new Expression(TipoDato.INT);
    :}
    | NUMBER:n
    {: RESULT = new Expression(TipoDato.INT, n); :}
    | LPAREN expression:e RPAREN
    {: RESULT = e; :}
    ;

selection_statement ::=
    IF LPAREN condition:c RPAREN compound_statement
    {:
        addInstruccion(new Instruccion(TipoInstruccion.IF, c.getOperandoIzq(), c.getOperador(), c.getOperandoDer(), null, cleft));
    :}
    | IF LPAREN condition:c RPAREN compound_statement ELSE compound_statement
    {:
        addInstruccion(new Instruccion(TipoInstruccion.IF, c.getOperandoIzq(), c.getOperador(), c.getOperandoDer(), null, cleft));
        addInstruccion(new Instruccion(TipoInstruccion.ELSE, null, null, null, null, cleft));
    :}
    ;

iteration_statement ::=
    WHILE
    {: tablaSimbolos.enterLoop(); :}
    LPAREN condition:c RPAREN compound_statement
    {:
        tablaSimbolos.exitLoop();
        addInstruccion(new Instruccion(TipoInstruccion.WHILE, c.getOperandoIzq(), c.getOperador(), c.getOperandoDer(), null, cleft));
    :}
    ;

jump_statement ::=
    BREAK SEMICOLON
    {:
        if (!tablaSimbolos.isInLoop()) {
            semanticAnalyzer.addError("'break' solo puede usarse dentro de ciclos", breakleft);
        }
    :}
    | CONTINUE SEMICOLON
    {:
        if (!tablaSimbolos.isInLoop()) {
            semanticAnalyzer.addError("'continue' solo puede usarse dentro de ciclos", continueleft);
        }
    :}
    ;

type ::= 
    INT     {: RESULT = TipoDato.INT; :}
    | CHAR  {: RESULT = TipoDato.CHAR; :}
    | VOID  {: RESULT = null; :}
    ;

condition ::=
    logical_expression:e
    {: RESULT = e; :}
    ;

logical_expression ::=
    logical_expression:l AND relational_expression:r
    {: RESULT = new Instruccion(TipoInstruccion.CONDITION, l.getOperandoIzq(), "&&", r.getOperandoIzq(), null, lleft); :}
    | logical_expression:l OR relational_expression:r
    {: RESULT = new Instruccion(TipoInstruccion.CONDITION, l.getOperandoIzq(), "||", r.getOperandoIzq(), null, lleft); :}
    | relational_expression:r
    {: RESULT = r; :}
    ;

relational_expression ::=
    arithmetic_expression:e1 comparison_operator:op arithmetic_expression:e2
    {: RESULT = new Instruccion(TipoInstruccion.CONDITION, e1.toString(), op, e2.toString(), null, e1left); :}
    ;

comparison_operator ::=
    EQUALS    {: RESULT = "=="; :}
    | NOT_EQUALS  {: RESULT = "!="; :}
    | LT      {: RESULT = "<"; :}
    | GT      {: RESULT = ">"; :}
    | LTEQ    {: RESULT = "<="; :}
    | GTEQ    {: RESULT = ">="; :}
    ;